import { __decorate } from "tslib";
import { attr, customElement, FASTElement, observable, Observable, } from "@microsoft/fast-element";
import { composedParent } from "../utilities/composed-parent";
const supportsAdoptedStylesheets = "adoptedStyleSheets" in window.ShadowRoot.prototype;
/**
 * Determines if the element is {@link DesignSystemConsumer}
 * @param element - the element to test.
 * @public
 */
export function isDesignSystemConsumer(element) {
    const provider = element.provider;
    return (provider !== null &&
        provider !== void 0 &&
        DesignSystemProvider.isDesignSystemProvider(provider));
}
/**
 * Behavior to connect a {@link DesignSystemConsumer} to the nearest {@link DesignSystemProvider}
 * @public
 */
export const designSystemConsumerBehavior = {
    bind(source) {
        source.provider = DesignSystemProvider.findProvider(source);
    },
    /* eslint-disable-next-line */
    unbind(source) { },
};
/**
 * A element to provide Design System values to consumers via CSS custom properties
 * and to resolve recipe values.
 *
 * @public
 */
export class DesignSystemProvider extends FASTElement {
    constructor() {
        super();
        /**
         * Allows other components to identify this as a provider.
         * Using instanceof DesignSystemProvider did not seem to work.
         *
         * @public
         */
        this.isDesignSystemProvider = true;
        /**
         * The design-system object.
         * This is "observable" but will notify on object mutation
         * instead of object assignment
         *
         * @public
         */
        this.designSystem = {};
        /**
         * Applies the default design-system values to the instance where properties
         * are not explicitly assigned. This is generally used to set the root design
         * system context.
         *
         * @public
         * @remarks
         * HTML Attribute: use-defaults
         */
        this.useDefaults = false;
        /**
         * The parent provider the the DesignSystemProvider instance.
         * @public
         */
        this.provider = null;
        /**
         * Stores all CSSCustomPropertyDefinitions registered with the provider.
         */
        this.cssCustomPropertyDefinitions = new Map();
        /**
         * Handle changes to design-system-provider IDL and content attributes
         * that reflect to design-system properties.
         */
        this.attributeChangeHandler = {
            handleChange: (source, key) => {
                const value = this[key];
                if (this.isValidDesignSystemValue(value)) {
                    this.designSystem[key] = value;
                    const property = this.designSystemProperties[key];
                    if (property && property.cssCustomProperty) {
                        this.setCustomProperty({
                            name: property.cssCustomProperty,
                            value,
                        });
                    }
                }
                else {
                    this.syncDesignSystemWithProvider();
                    const property = this.designSystemProperties[key].cssCustomProperty;
                    if (typeof property === "string") {
                        this.deleteCustomProperty(property);
                    }
                    this.writeCustomProperties();
                }
            },
        };
        /**
         * Handle changes to the local design-system property.
         */
        this.localDesignSystemChangeHandler = {
            handleChange: this.writeCustomProperties.bind(this),
        };
        /**
         * Handle changes to the upstream design-system provider
         */
        this.providerDesignSystemChangeHandler = {
            handleChange: (source, key) => {
                if (source[key] !== this.designSystem[key] &&
                    !this.isValidDesignSystemValue(this[key])) {
                    this.designSystem[key] = source[key];
                }
            },
        };
        /**
         * Writes a CSS custom property to the design system provider,
         * evaluating any function values with the design system.
         */
        this.setCustomProperty = (definition) => {
            this.customPropertyTarget.setProperty(`--${definition.name}`, this.evaluate(definition));
        };
        /**
         * Removes a CSS custom property from the provider.
         */
        this.deleteCustomProperty = (name) => {
            this.customPropertyTarget.removeProperty(`--${name}`);
        };
        if (supportsAdoptedStylesheets && this.shadowRoot !== null) {
            const sheet = new CSSStyleSheet();
            sheet.insertRule(":host{}");
            this.shadowRoot.adoptedStyleSheets = [
                ...this.shadowRoot.adoptedStyleSheets,
                sheet,
            ];
            this.customPropertyTarget = sheet.rules[0].style;
        }
        else {
            this.customPropertyTarget = this.style;
        }
        this.$fastController.addBehaviors([designSystemConsumerBehavior]);
    }
    /**
     * Read all tag-names that are associated to
     * design-system-providers
     *
     * @public
     */
    static get tagNames() {
        return DesignSystemProvider._tagNames;
    }
    /**
     * Determines if an element is a DesignSystemProvider
     * @param el - The element to test
     *
     * @public
     */
    static isDesignSystemProvider(el) {
        return (el.isDesignSystemProvider ||
            DesignSystemProvider.tagNames.indexOf(el.tagName) !== -1);
    }
    /**
     * Finds the closest design-system-provider
     * to an element.
     *
     * @param el - The element from which to begin searching.
     * @public
     */
    static findProvider(el) {
        if (isDesignSystemConsumer(el)) {
            return el.provider;
        }
        let parent = composedParent(el);
        while (parent !== null) {
            if (DesignSystemProvider.isDesignSystemProvider(parent)) {
                el.provider = parent; // Store provider on ourselves for future reference
                return parent;
            }
            else if (isDesignSystemConsumer(parent)) {
                el.provider = parent.provider;
                return parent.provider;
            }
            else {
                parent = composedParent(parent);
            }
        }
        return null;
    }
    /**
     * Registers a tag-name to be associated with
     * the design-system-provider class. All tag-names for DesignSystemProvider elements
     * must be registered for proper property resolution.
     *
     * @param tagName - the HTML Element tag name to register as a DesignSystemProvider.
     *
     * @public
     */
    static registerTagName(tagName) {
        const tagNameUpper = tagName.toUpperCase();
        if (DesignSystemProvider.tagNames.indexOf(tagNameUpper) === -1) {
            DesignSystemProvider._tagNames.push(tagNameUpper);
        }
    }
    useDefaultsChanged() {
        if (this.useDefaults) {
            const props = this.designSystemProperties;
            Object.keys(props).forEach((key) => {
                if (this[key] === void 0) {
                    this[key] = props[key].default;
                }
            });
        }
    }
    providerChanged(prev, next) {
        if (prev instanceof HTMLElement) {
            Object.keys(prev.designSystemProperties).forEach(key => {
                Observable.getNotifier(prev.designSystem).unsubscribe(this.providerDesignSystemChangeHandler, key);
            });
        }
        if (next instanceof HTMLElement &&
            DesignSystemProvider.isDesignSystemProvider(next)) {
            Object.keys(next.designSystemProperties).forEach(key => {
                Observable.getNotifier(next.designSystem).subscribe(this.providerDesignSystemChangeHandler, key);
            });
            this.syncDesignSystemWithProvider();
        }
    }
    /**
     * @internal
     */
    connectedCallback() {
        super.connectedCallback();
        const selfNotifier = Observable.getNotifier(this);
        const designSystemNotifier = Observable.getNotifier(this.designSystem);
        Object.keys(this.designSystemProperties).forEach(property => {
            observable(this.designSystem, property);
            selfNotifier.subscribe(this.attributeChangeHandler, property); // Notify ourselves when properties related to DS change
            designSystemNotifier.subscribe(this.localDesignSystemChangeHandler, property); // Notify ourselves when design system properties change
            const value = this[property];
            // If property is set then put it onto the design system
            if (this.isValidDesignSystemValue(value)) {
                this.designSystem[property] = value;
                const { cssCustomProperty } = this.designSystemProperties[property];
                if (typeof cssCustomProperty === "string") {
                    this.setCustomProperty({
                        name: cssCustomProperty,
                        value,
                    });
                }
            }
        });
        // Register all properties that may have been attached before construction
        if (Array.isArray(this.disconnectedCSSCustomPropertyRegistry)) {
            for (let i = 0; i < this.disconnectedCSSCustomPropertyRegistry.length; i++) {
                this.registerCSSCustomProperty(this.disconnectedCSSCustomPropertyRegistry[i]);
            }
            delete this.disconnectedCSSCustomPropertyRegistry;
        }
        if (Array.isArray(this.disconnectedRegistry)) {
            for (let i = 0; i < this.disconnectedRegistry.length; i++) {
                this.disconnectedRegistry[i](this);
            }
            delete this.disconnectedRegistry;
        }
    }
    /**
     * Register a {@link @microsoft/fast-foundation#CSSCustomPropertyDefinition} with the DeignSystemProvider.
     * Registering a {@link @microsoft/fast-foundation#CSSCustomPropertyDefinition} will create the CSS custom property.
     *
     * @param behavior - The {@link @microsoft/fast-foundation#CSSCustomPropertyDefinition} to register.
     * @public
     */
    registerCSSCustomProperty(behavior) {
        const cached = this.cssCustomPropertyDefinitions.get(behavior.name);
        if (cached) {
            cached.count += 1;
        }
        else {
            this.cssCustomPropertyDefinitions.set(behavior.name, Object.assign(Object.assign({}, behavior), { count: 1 }));
            this.setCustomProperty(behavior);
        }
    }
    /**
     * Unregister a {@link @microsoft/fast-foundation#CSSCustomPropertyDefinition} from the DeignSystemProvider.
     * If all registrations of the definition are unregistered, the CSS custom property will be removed.
     *
     * @param behavior - The {@link @microsoft/fast-foundation#CSSCustomPropertyDefinition} to register.
     * @public
     */
    unregisterCSSCustomProperty(behavior) {
        const cached = this.cssCustomPropertyDefinitions.get(behavior.name);
        if (cached) {
            cached.count -= 1;
            if (cached.count === 0) {
                this.cssCustomPropertyDefinitions.delete(behavior.name);
                this.deleteCustomProperty(behavior.name);
            }
        }
    }
    /**
     * Writes all CSS custom property definitions to the design system provider.
     */
    writeCustomProperties() {
        this.cssCustomPropertyDefinitions.forEach(this.setCustomProperty);
    }
    /**
     * Evaluates a CSSCustomPropertyDefinition with the current design system.
     *
     * @public
     */
    evaluate(definition) {
        return typeof definition.value === "function"
            ? // use spread on the designSystem object to circumvent memoization
                // done in the color recipes - we use the same *reference* in WC
                // for performance improvements but that throws off the recipes
                // We should look at making the recipes use simple args that
                // we can individually memoize.
                definition.value(Object.assign({}, this.designSystem))
            : definition.value;
    }
    /**
     * Synchronize the provider's design system with the local
     * overrides. Any value defined on the instance will take priority
     * over the value defined by the provider
     */
    syncDesignSystemWithProvider() {
        if (this.provider) {
            const designProperties = this.designSystemProperties;
            Object.keys(designProperties).forEach((key) => {
                const property = designProperties[key];
                if (!this.isValidDesignSystemValue(property)) {
                    this.designSystem[key] = this.provider.designSystem[key];
                }
            });
        }
    }
    isValidDesignSystemValue(value) {
        return value !== void 0 && value !== null;
    }
}
/**
 * Stores a list of all element tag-names that associated
 * to design-system-providers
 */
DesignSystemProvider._tagNames = [];
__decorate([
    attr({ attribute: "use-defaults", mode: "boolean" })
], DesignSystemProvider.prototype, "useDefaults", void 0);
__decorate([
    observable
], DesignSystemProvider.prototype, "provider", void 0);
/**
 * Defines a design-system-provider custom element, registering the tag-name so that the element can be property resolved by {@link DesignSystemConsumer | DesignSystemConsumers}.
 *
 * @param nameOrDef - the name or {@link @microsoft/fast-element#PartialFASTElementDefinition | element definition}
 * @public
 */
export function designSystemProvider(nameOrDef) {
    return (providerCtor) => {
        customElement(nameOrDef)(providerCtor);
        providerCtor.registerTagName(typeof nameOrDef === "string" ? nameOrDef : nameOrDef.name);
    };
}
