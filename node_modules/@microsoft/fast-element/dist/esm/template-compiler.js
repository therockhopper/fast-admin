import { DOM, _interpolationEnd, _interpolationStart } from "./dom";
import { BindingDirective } from "./directives/binding";
const compilationContext = { locatedDirectives: 0, targetIndex: -1 };
function createAggregateBinding(parts) {
    if (parts.length === 1) {
        compilationContext.locatedDirectives++;
        return parts[0];
    }
    let targetName;
    const partCount = parts.length;
    const finalParts = parts.map((x) => {
        if (typeof x === "string") {
            return () => x;
        }
        targetName = x.targetName || targetName;
        compilationContext.locatedDirectives++;
        return x.binding;
    });
    const binding = (scope, context) => {
        let output = "";
        for (let i = 0; i < partCount; ++i) {
            output += finalParts[i](scope, context);
        }
        return output;
    };
    const directive = new BindingDirective(binding);
    directive.targetName = targetName;
    return directive;
}
const interpolationEndLength = _interpolationEnd.length;
function parseContent(value, directives) {
    const valueParts = value.split(_interpolationStart);
    if (valueParts.length === 1) {
        return null;
    }
    const bindingParts = [];
    for (let i = 0, ii = valueParts.length; i < ii; ++i) {
        const current = valueParts[i];
        const index = current.indexOf(_interpolationEnd);
        let literal;
        if (index === -1) {
            literal = current;
        }
        else {
            const directiveIndex = parseInt(current.substring(0, index));
            bindingParts.push(directives[directiveIndex]);
            literal = current.substring(index + interpolationEndLength);
        }
        if (literal !== "") {
            bindingParts.push(literal);
        }
    }
    return bindingParts;
}
function compileAttributes(node, directives, factories, includeBasicValues = false) {
    const attributes = node.attributes;
    for (let i = 0, ii = attributes.length; i < ii; ++i) {
        const attr = attributes[i];
        const attrValue = attr.value;
        const parseResult = parseContent(attrValue, directives);
        let result = null;
        if (parseResult === null) {
            if (includeBasicValues) {
                result = new BindingDirective(() => attrValue);
                result.targetName = attr.name;
            }
        }
        else {
            result = createAggregateBinding(parseResult);
        }
        if (result !== null) {
            node.removeAttributeNode(attr);
            i--;
            ii--;
            result.targetIndex = compilationContext.targetIndex;
            factories.push(result);
        }
    }
}
function captureContentBinding(directive, viewBehaviorFactories) {
    directive.targetAtContent();
    directive.targetIndex = compilationContext.targetIndex;
    viewBehaviorFactories.push(directive);
    compilationContext.locatedDirectives++;
}
function compileContent(node, directives, factories, walker) {
    const parseResult = parseContent(node.textContent, directives);
    if (parseResult !== null) {
        let lastNode = node;
        for (let i = 0, ii = parseResult.length; i < ii; ++i) {
            const currentPart = parseResult[i];
            const currentNode = i === 0
                ? node
                : lastNode.parentNode.insertBefore(document.createTextNode(""), lastNode.nextSibling);
            if (typeof currentPart === "string") {
                currentNode.textContent = currentPart;
            }
            else {
                currentNode.textContent = " ";
                captureContentBinding(currentPart, factories);
            }
            lastNode = currentNode;
            compilationContext.targetIndex++;
            if (currentNode !== node) {
                walker.nextNode();
            }
        }
        compilationContext.targetIndex--;
    }
}
/**
 * Compiles a template and associated directives into a raw compilation
 * result which include a cloneable DocumentFragment and factories capable
 * of attaching runtime behavior to nodes within the fragment.
 * @param template - The template to compile.
 * @param directives - The directives referenced by the template.
 * @remarks
 * The template that is provided for compilation is altered in-place
 * and cannot be compiled again. If the original template must be preserved,
 * it is recommended that you clone the original and pass the clone to this API.
 * @public
 */
export function compileTemplate(template, directives) {
    const hostBehaviorFactories = [];
    compilationContext.locatedDirectives = 0;
    compileAttributes(template, directives, hostBehaviorFactories, true);
    const fragment = template.content;
    const viewBehaviorFactories = [];
    const directiveCount = directives.length;
    const walker = DOM.createTemplateWalker(fragment);
    compilationContext.targetIndex = -1;
    while (compilationContext.locatedDirectives < directiveCount) {
        const node = walker.nextNode();
        if (node === null) {
            break;
        }
        compilationContext.targetIndex++;
        switch (node.nodeType) {
            case 1: // element node
                compileAttributes(node, directives, viewBehaviorFactories);
                break;
            case 3: // text node
                compileContent(node, directives, viewBehaviorFactories, walker);
                break;
            case 8: // comment
                if (DOM.isMarker(node)) {
                    const directive = directives[DOM.extractDirectiveIndexFromMarker(node)];
                    directive.targetIndex = compilationContext.targetIndex;
                    compilationContext.locatedDirectives++;
                    viewBehaviorFactories.push(directive);
                }
                else {
                    node.parentNode.removeChild(node);
                    compilationContext.targetIndex--;
                }
        }
    }
    let targetOffset = 0;
    if (DOM.isMarker(fragment.firstChild)) {
        // If the first node in a fragment is a marker, that means it's an unstable first node,
        // because something like a when, repeat, etc. could add nodes before the marker.
        // To mitigate this, we insert a stable first node. However, if we insert a node,
        // that will alter the result of the TreeWalker. So, we also need to offset the target index.
        fragment.insertBefore(document.createComment(""), fragment.firstChild);
        targetOffset = -1;
    }
    return {
        fragment,
        viewBehaviorFactories,
        hostBehaviorFactories,
        targetOffset,
    };
}
